---
title: "ModeloMasculino"
author: "PauGalindo"
date: "2025-07-29"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
library(lmerTest)
library(ggplot2)
library(lattice)
library(ggpubr)
library(moments)
library(sjPlot)
library(car)
library(lmtest)
library(corrplot)
library(descr)
library(psych)
library(dplyr)
library(gridExtra)
library(kableExtra)
library(Matrix)
library(lme4)
library(texreg)
library(lmeresampler)
library(rsample)
library(flextable)
library(xtable)
```

# Carga y preprocesamiento de datos

```{r carga-datos}
datos <- readxl::read_excel("C:/NAS_PAU/TFG/BBDD_Unificada/DatasetCompleto.xlsx")

# FACTORIZAR VARIABLES CATEGÓRICAS DEL DATASET

# Jugador y usuario de Instagram
datos$usuario <- as.factor(datos$usuario)

# Día de la semana (de número a nombre)
datos$dia_semana <- factor(datos$dia_semana,
                           levels = 1:7,
                           labels = c("Lun", "Mar", "Mié", "Jue", "Vie", "Sáb", "Dom"))

# Fin de semana (binaria)
datos$fin_de_semana <- factor(datos$fin_de_semana, levels = c(0,1), labels = c("No", "Sí"))

# Majors (binarias)
datos$Masters <- factor(datos$Masters, levels = c(0,1), labels = c("No", "Sí"))
datos$PGA_Championship <- factor(datos$PGA_Championship, levels = c(0,1), labels = c("No", "Sí"))
datos$US_Open <- factor(datos$US_Open, levels = c(0,1), labels = c("No", "Sí"))
datos$The_Open <- factor(datos$The_Open, levels = c(0,1), labels = c("No", "Sí"))

# Imagen: carrusel, selfie, otro golfista
datos$carrusel <- factor(datos$carrusel, levels = c(0,1), labels = c("No", "Sí"))
datos$selfie <- factor(datos$selfie, levels = c(0,1), labels = c("No", "Sí"))
datos$otro_golfista <- factor(datos$otro_golfista, levels = c(0,1), labels = c("No", "Sí"))

# Imagen: campo de golf e indoor
datos$campo_golf <- factor(datos$campo_golf, levels = c(0,1), labels = c("No", "Sí"))
datos$indoor <- factor(datos$indoor, levels = c(0,1), labels = c("No", "Sí"))

# Emoción dominante en la imagen
datos$emocion <- factor(datos$emocion)
datos$emocion <- relevel(datos$emocion, ref = "neutral")  

# Circuito al que pertenece el jugador
datos$circuito <- as.factor(datos$circuito)

# Juegos Olímpicos
datos$juegos_olimpicos <- factor(datos$juegos_olimpicos, levels = c(0,1), labels = c("No", "Sí"))

# Otras binarias
datos$es_usa <- factor(datos$es_usa, levels = c(0,1), labels = c("No", "Sí"))

# Factorizar top
cols_top <- grep("_top$", names(datos), value = TRUE)

for (col in cols_top) {
  datos[[col]] <- factor(datos[[col]], levels = c(0,1), labels = c("No", "Sí"))
}

#Filtramos para eliminar las publicaciones con likes -1 y comentarios -1:

datos.likes <- datos %>% filter(n_likes >= 0)
datos.comentarios <- datos%>% filter(n_comentarios >= 0)
```

# Análisis exploratorio

## Variables categóricas y likes

```{r boxplot-likes-categoricas, fig.width=15, fig.height=15}
par(mfrow = c(4, 4))
vars_categoricas <- c("carrusel", "selfie", "otro_golfista", "campo_golf", "indoor",
                      "Masters", "PGA_Championship", "US_Open", "The_Open", "es_usa",
                      "circuito", "emocion", "dia_semana", "juegos_olimpicos")
for (var in vars_categoricas) {
  boxplot(n_likes ~ get(var), data = datos.likes, main = paste("Likes por", var), xlab = var, outline = FALSE)
}
cols_top <- grep("_top$", names(datos.likes), value = TRUE)
for (top in cols_top) {
  boxplot(n_likes ~ get(top), data = datos.likes, main = paste("Likes por", top), xlab = top, outline = FALSE)
}

for (var in vars_categoricas) {
  boxplot(n_likes ~ get(var), data = datos.comentarios, main = paste("Comentarios por", var), xlab = var, outline = FALSE)
}
cols_top <- grep("_top$", names(datos.comentarios), value = TRUE)
for (top in cols_top) {
  boxplot(n_likes ~ get(top), data = datos.comentarios, main = paste("Comentarios por", top), xlab = top, outline = FALSE)
}
par(mfrow = c(1, 1))
```
```{r}

# Carpeta de salida
out_dir <- "figuras_boxplots"
if (!dir.exists(out_dir)) dir.create(out_dir, showWarnings = FALSE)

present_vars <- function(vars, data) intersect(vars, names(data))

# Dibuja 3 boxplots verticales en 1 página (PDF único)
export_boxplots_onepage <- function(file, data, response, vars3,
                                    width = 8, height = 12,
                                    main_prefix = NULL) {
  if (is.null(main_prefix)) main_prefix <- response
  pdf(file, width = width, height = height); on.exit(dev.off(), add = TRUE)

  op <- par(no.readonly = TRUE); on.exit(par(op), add = TRUE)
  par(mfrow = c(3,1), mar = c(4.5,4,3,1), mgp = c(2.2,0.8,0), cex.axis = 0.9, cex.lab = 0.95)

  y <- data[[response]]
  for (v in vars3) {
    x <- as.factor(data[[v]])
    if (all(is.na(y)) || all(is.na(x))) { plot.new(); title(main=sprintf("%s por %s (sin datos)", response, v)); next }
    boxplot(y ~ x,
            main   = sprintf("%s por %s", main_prefix, v),
            xlab   = v, ylab = response,
            outline= FALSE,
            las    = 1,
            col    = "gray90",
            border = "black",
            boxwex = 0.6,
            lwd    = 1.2,
            medlwd = 2.5,
            whisklwd = 1,
            staplelty = 1, staplewex = 0.5)
    grid(nx = NA, ny = NULL, lty = 3)
  }
  invisible(TRUE)
}

# Divide un vector de variables en grupos de tamaño n (aquí 3)
split_in_chunks <- function(x, n = 3) {
  if (!length(x)) return(list())
  split(x, ceiling(seq_along(x) / n))
}

# Exporta muchos PDFs de 1 página a partir de una lista de variables
export_many_pdfs <- function(file_stub, data, response, vars,
                             main_prefix = NULL, chunk_size = 3) {
  vars <- present_vars(vars, data)
  chunks <- split_in_chunks(vars, n = chunk_size)
  if (!length(chunks)) {
    warning("Sin variables para: ", file_stub)
    return(invisible(NULL))
  }
  for (i in seq_along(chunks)) {
    file_i <- file.path(out_dir, sprintf("%s_p%02d.pdf", file_stub, i))
    export_boxplots_onepage(file = file_i,
                            data = data,
                            response = response,
                            vars3 = chunks[[i]],
                            main_prefix = main_prefix)
  }
  invisible(TRUE)
}

# Variables categóricas unificadas
# Base de categóricas "manuales"
vars_categoricas_base <- c(
  "carrusel","selfie","otro_golfista","campo_golf","indoor",
  "Masters","PGA_Championship","US_Open","The_Open","es_usa",
  "circuito","emocion","dia_semana","juegos_olimpicos"
)

# Añade automáticamente todas las *_top presentes en likes o comentarios
vars_top_all <- union(
  grep("_top$", names(datos.likes), value = TRUE),
  grep("_top$", names(datos.comentarios), value = TRUE)
)

# Lista final unificada (única y ordenada por aparición)
vars_categoricas_todo <- unique(c(vars_categoricas_base, vars_top_all))

# Exportación
# Likes (todas las categóricas + top)
export_many_pdfs(file_stub = "likes_categoricas_3vertical",
                 data = datos.likes, response = "n_likes",
                 vars = vars_categoricas_todo, main_prefix = "Likes")

# Comentarios (todas las categóricas + top)
export_many_pdfs(file_stub = "comentarios_categoricas_3vertical",
                 data = datos.comentarios, response = "n_comentarios",
                 vars = vars_categoricas_todo, main_prefix = "Comentarios")

# Comprobación (opcional)
message("Generado en: ", normalizePath(out_dir, winslash = "/"))
print(list.files(out_dir, pattern = "_p\\d+\\.pdf$", full.names = TRUE))



```

## Correlación variables continuas

```{r correlacion-continuas}
vars_continuas <- c('posicion_owgr', 'n_fotos', 'n_videos','n_palabras','n_hashtags','n_menciones','n_emojis','n_rostros','edad','inicio_profesional','dinero_2024','n_otros_circuitos','n_torneos_total','n_torneos_pga','n_torneos_liv','n_torneos_otros_circuitos','n_majors','seguidores','publicaciones','n_likes', 'n_comentarios')
corrplot(cor(select(datos.likes, all_of(vars_continuas))), method = "color", type = "upper", order = "hclust",
         addCoef.col = "black", tl.col = "black", tl.srt = 45, tl.cex = 0.8, number.cex = 0.7)
corrplot(cor(select(datos.comentarios, all_of(vars_continuas))), method = "color", type = "upper", order = "hclust",
         addCoef.col = "black", tl.col = "black", tl.srt = 45, tl.cex = 0.8, number.cex = 0.7)
```

## Transformaciones y normalidad

```{r transformaciones-continuas, resultados='asis'}
vars_continuas_estudio <- c('posicion_owgr', 'n_fotos', 'n_videos', 'n_palabras', 'n_hashtags', 'n_menciones','n_emojis','n_rostros','edad','inicio_profesional','dinero_2024','n_otros_circuitos','n_torneos_total','n_torneos_pga','n_torneos_liv','n_torneos_otros_circuitos','n_majors','seguidores','publicaciones','n_likes','n_comentarios')
par(mfrow = c(4, 4))
for (variable in vars_continuas_estudio) {
  variable.sqrt <- paste0(variable, ".sqrt")
  variable.log <- paste0(variable, ".log")
  datos.likes[[variable.sqrt]] <- sqrt(datos.likes[[variable]])
  x <- ifelse(datos.likes[[variable]] == 0, 1, datos.likes[[variable]])
  datos.likes[[variable.log]] <- log(x)
  skew.raw <- skewness(datos.likes[[variable]], na.rm = TRUE)
  skew.sqrt <- skewness(datos.likes[[variable.sqrt]], na.rm = TRUE)
  skew.log <- skewness(datos.likes[[variable.log]], na.rm = TRUE)
  g1 <- ggplot(datos.likes, aes(x = !!sym(variable))) + geom_density() + stat_overlay_normal_density(color = "red", linetype = "dashed") + labs(title = paste0("Bruto (Skew=", round(skew.raw,2), ")"))
  g2 <- ggplot(datos.likes, aes(x = !!sym(variable.sqrt))) + geom_density() + stat_overlay_normal_density(color = "red", linetype = "dashed") + labs(title = paste0("Raíz (Skew=", round(skew.sqrt,2), ")"))
  g3 <- ggplot(datos.likes, aes(x = !!sym(variable.log))) + geom_density() + stat_overlay_normal_density(color = "red", linetype = "dashed") + labs(title = paste0("Log (Skew=", round(skew.log,2), ")"))
  grid.arrange(g1, g2, g3, ncol = 3)
  df.resultados <- data.frame(original = skew.raw, raiz = skew.sqrt, log = skew.log)
  print(kable(df.resultados, caption = paste0("Skewness para ", variable), digits = 2))
}
for (variable in vars_continuas_estudio) {
  variable.sqrt <- paste0(variable, ".sqrt")
  variable.log <- paste0(variable, ".log")
  datos.comentarios[[variable.sqrt]] <- sqrt(datos.comentarios[[variable]])
  x <- ifelse(datos.comentarios[[variable]] == 0, 1, datos.comentarios[[variable]])
  datos.comentarios[[variable.log]] <- log(x)
  skew.raw <- skewness(datos.comentarios[[variable]], na.rm = TRUE)
  skew.sqrt <- skewness(datos.comentarios[[variable.sqrt]], na.rm = TRUE)
  skew.log <- skewness(datos.comentarios[[variable.log]], na.rm = TRUE)
  g1 <- ggplot(datos.comentarios, aes(x = !!sym(variable))) + geom_density() + stat_overlay_normal_density(color = "red", linetype = "dashed") + labs(title = paste0("Bruto (Skew=", round(skew.raw,2), ")"))
  g2 <- ggplot(datos.comentarios, aes(x = !!sym(variable.sqrt))) + geom_density() + stat_overlay_normal_density(color = "red", linetype = "dashed") + labs(title = paste0("Raíz (Skew=", round(skew.sqrt,2), ")"))
  g3 <- ggplot(datos.comentarios, aes(x = !!sym(variable.log))) + geom_density() + stat_overlay_normal_density(color = "red", linetype = "dashed") + labs(title = paste0("Log (Skew=", round(skew.log,2), ")"))
  grid.arrange(g1, g2, g3, ncol = 3)
  df.resultados <- data.frame(original = skew.raw, raiz = skew.sqrt, log = skew.log)
  print(kable(df.resultados, caption = paste0("Skewness para ", variable), digits = 2))
}
```
```{r}
out_dir <- "figuras"
if (!dir.exists(out_dir)) dir.create(out_dir, showWarnings = FALSE)

vars_continuas_estudio <- c(
  'posicion_owgr','n_fotos','n_videos','n_palabras','n_hashtags','n_menciones',
  'n_emojis','n_rostros','edad','inicio_profesional','dinero_2024','n_otros_circuitos',
  'n_torneos_total','n_torneos_pga','n_torneos_liv','n_torneos_otros_circuitos',
  'n_majors','seguidores','publicaciones','n_likes','n_comentarios'
)

# utilidade
skewness_vec <- function(x) {
  x <- x[is.finite(x)]
  if (length(x) < 3) return(NA_real_)
  m <- mean(x); s <- sd(x)
  if (!is.finite(s) || s == 0) return(NA_real_)
  mean(((x - m)/s)^3)
}

normal_overlay <- function(df, aes_x) {
  m <- mean(df[[aes_x]], na.rm = TRUE)
  s <- sd(df[[aes_x]], na.rm = TRUE)
  if (!is.finite(m) || !is.finite(s) || s == 0) return(NULL)
  stat_function(fun = function(z) dnorm(z, mean = m, sd = s),
                linetype = "dashed", linewidth = 0.5, color = "red")
}

make_density_plot <- function(df, colname, titulo) {
  ggplot(df, aes(x = .data[[colname]])) +
    geom_density(na.rm = TRUE) +
    normal_overlay(df, colname) +
    labs(title = titulo, x = colname, y = "Densidad") +
    theme_minimal(base_size = 9) +
    theme(plot.title = element_text(face = "bold", size = 9))
}

# Triptico (Bruto, Raíz, Log1p) como grob de 1x3 para UNA variable
triptych_grob <- function(data, var) {
  df <- data %>% select(all_of(var)) %>% rename(x = all_of(var))
  df <- df %>% mutate(
    x_sqrt  = sqrt(pmax(x, 0)),
    x_log1p = log1p(pmax(x, 0))
  )
  sk_raw  <- skewness_vec(df$x)
  sk_sqrt <- skewness_vec(df$x_sqrt)
  sk_log  <- skewness_vec(df$x_log1p)

  g1 <- make_density_plot(df %>% rename(!!var := x),
                          var, sprintf("Bruto (Skew=%.2f)", sk_raw))
  g2 <- make_density_plot(df %>% rename(!!paste0(var,".sqrt") := x_sqrt),
                          paste0(var,".sqrt"), sprintf("Raíz (Skew=%.2f)", sk_sqrt))
  g3 <- make_density_plot(df %>% rename(!!paste0(var,".log1p") := x_log1p),
                          paste0(var,".log1p"), sprintf("Log1p (Skew=%.2f)", sk_log))

  grob <- arrangeGrob(g1, g2, g3, ncol = 3)
  list(grob = grob,
       skew = tibble(variable = var,
                     skew_bruto = sk_raw, skew_raiz = sk_sqrt, skew_log1p = sk_log))
}

# Triplico vacío (1x3) para rellenar filas y mantener 1/3 de altura
empty_triptych <- function() {
  gridExtra::arrangeGrob(grid::nullGrob(), grid::nullGrob(), grid::nullGrob(), ncol = 3)
}

# Divide en grupos de tamaño n (aquí 3 variables por página)
split_in_chunks <- function(x, n = 3) {
  x <- x[x %in% names(df_dummy)]  # df_dummy se definirá en export
  if (!length(x)) return(list())
  split(x, ceiling(seq_along(x) / n))
}

# Exporta en lotes de 3 variables/página -> PDF p01, p02, ...
export_model_batches <- function(datos_modelo, modelo_tag = c("modelo1","modelo2"),
                                 vars = vars_continuas_estudio,
                                 page_vars = 3,
                                 width = 8, height = 11.5) {
  modelo_tag <- match.arg(modelo_tag)

  # para filtrar variables existentes
  assign("df_dummy", datos_modelo, inherits = TRUE)
  chunks <- split_in_chunks(vars, n = page_vars)

  skew_acc <- list()
  pdf_names <- character(0)

  for (i in seq_along(chunks)) {
    vars_i <- chunks[[i]]
    triptics <- lapply(vars_i, function(v) triptych_grob(datos_modelo, v))

    # recolecta skew
    skew_acc[[length(skew_acc)+1]] <- bind_rows(lapply(triptics, `[[`, "skew"))

    # pad: si hay menos de 3 variables, añade filas vacías hasta llegar a 3
    if (length(triptics) < 3) {
      for (k in seq_len(3 - length(triptics))) {
        triptics[[length(triptics) + 1]] <- list(grob = empty_triptych())
      }
    }

    # compone página: 3 filas (cada fila = 1 triptico 1x3) con alturas fijas 1/3
    page_grob <- gridExtra::arrangeGrob(
      grobs = lapply(triptics[1:3], `[[`, "grob"),
      ncol = 1,
      heights = grid::unit(rep(1, 3), "null")
    )

    file_pdf <- file.path(out_dir, sprintf("%s_densidades_p%02d.pdf", modelo_tag, i))
    pdf(file_pdf, width = width, height = height)
    grid.draw(page_grob)
    dev.off()
    pdf_names <- c(pdf_names, basename(file_pdf))
  }

  # CSV de skewness
  if (length(skew_acc)) {
    write_csv(bind_rows(skew_acc),
              file.path(out_dir, sprintf("%s_skewness.csv", modelo_tag)))
  }

  list(total = length(pdf_names), pdfs = pdf_names)
}

# Ejecutar
# Modelo 1 = likes, Modelo 2 = comentarios
res1 <- export_model_batches(datos.likes,        "modelo1",
                             vars = vars_continuas_estudio, page_vars = 3)
res2 <- export_model_batches(datos.comentarios,  "modelo2",
                             vars = vars_continuas_estudio, page_vars = 3)

message("PDFs creados en: ", normalizePath(out_dir, winslash = "/"))
print(res1$pdfs); print(res2$pdfs)

# Bloque LaTeX automático (caption arriba + fuente)
make_latex_block <- function(pdfs, titulo_base, label_prefix) {
  N <- length(pdfs); lines <- c()
  for (i in seq_along(pdfs)) {
    lines <- c(lines,
      "\\begin{figure}[t]",
      sprintf("  \\caption{%s (%d/%d)}", titulo_base, i, N),
      "  \\centering",
      sprintf("  \\includegraphics[width=\\linewidth]{%s}", pdfs[i]),
      "  \\begin{center}\\footnotesize \\textbf{Fuente:} Elaboración propia.\\end{center}",
      sprintf("  \\label{fig:%s-%02d}", label_prefix, i),
      "\\end{figure}", "")
  }
  lines
}

latex_modelo1 <- make_latex_block(res1$pdfs, "Distribuciones del Modelo 1", "modelo1")
latex_modelo2 <- make_latex_block(res2$pdfs, "Distribuciones del Modelo 2", "modelo2")
writeLines(c("% ----- BLOQUE AUTO: Densidades (3 variables/hoja) -----",
             latex_modelo1, latex_modelo2),
           con = file.path(out_dir, "bloque_densidades_3porhoja.tex"))
message("LaTeX escrito en: ", normalizePath(file.path(out_dir, "bloque_densidades_3porhoja.tex"),
                                            winslash = "/"))

```

## Resumen descriptivo

```{r resumen-descriptivo}
tabla_descriptiva <- describe(select(datos.likes, all_of(vars_continuas))) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Variable") %>%
  select(Variable, n, mean, sd, median, min, max, skew, kurtosis)
kable(tabla_descriptiva, digits = 2, format = "latex", booktabs = TRUE,
      caption = "Resumen estadístico de variables continuas") %>%
  kable_styling(latex_options = c("scale_down"), position = "center")

tabla_descriptiva <- describe(select(datos.comentarios, all_of(vars_continuas))) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Variable") %>%
  select(Variable, n, mean, sd, median, min, max, skew, kurtosis)
kable(tabla_descriptiva, digits = 2, format = "latex", booktabs = TRUE,
      caption = "Resumen estadístico de variables continuas") %>%
  kable_styling(latex_options = c("scale_down"), position = "center")
```

# Modelos Lineales Mixtos

## Modelo de Likes

```{r modelo-likes}
modelo.likes <- lmer(
  n_likes.log ~ posicion_owgr.log + n_fotos + n_videos + n_palabras.log + n_hashtags + 
    n_menciones + n_emojis + n_rostros + edad.log + inicio_profesional + dinero_2024.log + 
    n_otros_circuitos + n_torneos_total + n_torneos_pga + n_torneos_liv + n_torneos_otros_circuitos +
    n_majors + seguidores.log + publicaciones.log + 
    carrusel + selfie + otro_golfista + campo_golf + indoor +
    Masters + PGA_Championship + US_Open + The_Open + es_usa + circuito + emocion + 
    dia_semana + juegos_olimpicos +
    brysondechambeau_top + tyrrellhatton_top + jonrahm_top + joaco_niemann_top +
    cameronsmithgolf_top + scottie.scheffler_top + xanderschauffele_top + rorymcilroy_top + 
    collin_morikawa_top + luddeaberg_top +
    (1 | usuario),
  data = datos.likes,
  REML = FALSE
)
summary(modelo.likes)
```

```{r tabla-likes}
tab_model(modelo.likes)
```

```{r qqplot-likes}
qqPlot(resid(modelo.likes), main = 'Gráfico QQ Normal - Likes')
```

## Modelo de Comentarios

```{r modelo-comentarios}
modelo.comentarios <- lmer(
  n_comentarios.log ~ posicion_owgr.log + n_fotos + n_videos + n_palabras.log + n_hashtags + 
    n_menciones + n_emojis + n_rostros + edad.log + inicio_profesional + dinero_2024.log + 
    n_otros_circuitos + n_torneos_total + n_torneos_pga + n_torneos_liv + n_torneos_otros_circuitos +
    n_majors + seguidores.log + publicaciones.log + 
    carrusel + selfie + otro_golfista + campo_golf + indoor +
    Masters + PGA_Championship + US_Open + The_Open + es_usa + circuito + emocion + 
    dia_semana + juegos_olimpicos +
    brysondechambeau_top + tyrrellhatton_top + jonrahm_top + joaco_niemann_top +
    cameronsmithgolf_top + scottie.scheffler_top + xanderschauffele_top + rorymcilroy_top + 
    collin_morikawa_top + luddeaberg_top +
    (1 | usuario),
  data = datos.comentarios,
  REML = FALSE
)
summary(modelo.comentarios)
```

```{r tabla-comentarios}
tab_model(modelo.comentarios)
```

```{r qqplot-comentarios}
qqPlot(resid(modelo.comentarios), main = 'Gráfico QQ Normal - Comentarios')
```

# Bootstrap

```{r bootstrap-likes, cache=TRUE}
set.seed(456)
bootstrap_resultados_likes <- bootstrap(
  model = modelo.likes,
  .f = fixef,
  type = "case",
  resample = c(TRUE, TRUE),
  B = 5000
)
saveRDS(bootstrap_resultados_likes, "C:/NAS_PAU/TFG/AnalisisGolf/bootstrap_5000_likes_Masculino.rds")
#bootstrap_resultados_likes <- readRDS("C:/NAS_PAU/TFG/AnalisisGolf/bootstrap_5000_likes_Masculino.rds")
conf_intervals_likes <- confint(bootstrap_resultados_likes, type = "perc")
print(conf_intervals_likes, n = 55)
```

```{r bootstrap-comentarios, cache=TRUE}
set.seed(456)
bootstrap_resultados_comentarios <- bootstrap(
  model = modelo.comentarios,
  .f = fixef,
  type = "case",
  resample = c(TRUE, TRUE),
  B = 5000
)
saveRDS(bootstrap_resultados_comentarios, "C:/NAS_PAU/TFG/AnalisisGolf/bootstrap_5000_comentarios_Masculino.rds")
#bootstrap_resultados_comentarios <- readRDS("C:/NAS_PAU/TFG/AnalisisGolf/bootstrap_5000_comentarios_Masculino.rds")
conf_intervals_comentarios <- confint(bootstrap_resultados_comentarios, type = "perc")
print(conf_intervals_comentarios, n = 55)
```

```{r}
# Crear dataframe de intervalos y marcar significativos
df.confint_likes <- as.data.frame(conf_intervals_likes)
data_coef_likes <- df.confint_likes %>%
  mutate(significativo = (lower > 0 & upper > 0) | (lower < 0 & upper < 0))

# Formatear resultados
formatea.resultados.modelo_likes <- function(df.resultados.bootstrap_likes){
  data.frame(
    coef.boot = round(df.resultados.bootstrap_likes$estimate, 3),
    ci.boot = paste0('[', round(df.resultados.bootstrap_likes$lower, 3), ', ', round(df.resultados.bootstrap_likes$upper, 3), ']')
  )
}

# Preparar tabla
df.resultados.likes <- formatea.resultados.modelo_likes(data_coef_likes) %>%
  mutate(
    Predictores = data_coef_likes$term,
    significativo = data_coef_likes$significativo
  ) %>%
  select(Predictores, coef.boot, ci.boot, significativo)

colnames(df.resultados.likes)[2:3] <- c("coef.likes", "ci.likes")

# Crear cabecera sin la columna significativo
df.cabecera.likes <- data.frame(
  col_keys = c("Predictores", "coef.likes", "ci.likes"),
  nivel1 = c("", "Likes", "Likes"),
  nivel2 = c("Predictores", "Coef.", "IC95%"),
  stringsAsFactors = FALSE
)

# Tabla flextable
ft_likes <- flextable(df.resultados.likes[, 1:3]) %>%
  set_header_df(df.cabecera.likes, key = "col_keys") %>%
  merge_h(part = "header") %>%
  bold(i = ~ df.resultados.likes$significativo == TRUE, j = 2:3, part = "body") %>%
  autofit()


# Mostrar flextable
ft_likes

```

```{r}
# Crear dataframe de intervalos y marcar significativos
df.confint_comentarios <- as.data.frame(conf_intervals_comentarios)
data_coef_comentarios <- df.confint_comentarios %>%
  mutate(significativo = (lower > 0 & upper > 0) | (lower < 0 & upper < 0))

# Formatear resultados
formatea.resultados.modelo_comentarios <- function(df.resultados.bootstrap_comentarios){
  data.frame(
    coef.boot = round(df.resultados.bootstrap_comentarios$estimate, 3),
    ci.boot = paste0('[', round(df.resultados.bootstrap_comentarios$lower, 3), ', ', round(df.resultados.bootstrap_comentarios$upper, 3), ']')
  )
}

# Preparar tabla
df.resultados.comentarios <- formatea.resultados.modelo_comentarios(data_coef_comentarios) %>%
  mutate(
    Predictores = data_coef_comentarios$term,
    significativo = data_coef_comentarios$significativo
  ) %>%
  select(Predictores, coef.boot, ci.boot, significativo)

colnames(df.resultados.comentarios)[2:3] <- c("coef.comentarios", "ci.comentarios")

# Crear cabecera sin la columna significativo
df.cabecera.comentarios <- data.frame(
  col_keys = c("Predictores", "coef.comentarios", "ci.comentarios"),
  nivel1 = c("", "Comentarios", "Comentarios"),
  nivel2 = c("Predictores", "Coef.", "IC95%"),
  stringsAsFactors = FALSE
)

# Tabla flextable
ft_comentarios <- flextable(df.resultados.comentarios[, 1:3]) %>%
  set_header_df(df.cabecera.comentarios, key = "col_keys") %>%
  merge_h(part = "header") %>%
  bold(i = ~ df.resultados.comentarios$significativo == TRUE, j = 2:3, part = "body") %>%
  autofit()


# Mostrar flextable
ft_comentarios

```

```{r}
# Procesar Likes
df.confint_likes <- as.data.frame(conf_intervals_likes)
data_coef_likes <- df.confint_likes %>%
  mutate(significativo = (lower > 0 & upper > 0) | (lower < 0 & upper < 0))

# Procesar Comentarios
df.confint_comentarios <- as.data.frame(conf_intervals_comentarios)
data_coef_comentarios <- df.confint_comentarios %>%
  mutate(significativo = (lower > 0 & upper > 0) | (lower < 0 & upper < 0))

# Crear resultados para combinar
resultados_likes <- data_coef_likes %>%
  select(term, estimate, lower, upper)

resultados_comentarios <- data_coef_comentarios %>%
  select(term, estimate, lower, upper)

# Renombrar columnas antes de unir
colnames(resultados_likes)[2:4] <- c("Est_Likes", "Lower_Likes", "Upper_Likes")
colnames(resultados_comentarios)[2:4] <- c("Est_Comentarios", "Lower_Comentarios", "Upper_Comentarios")

# Unir por término predictor
df_combinado <- resultados_likes %>%
  full_join(resultados_comentarios, by = "term") %>%
  mutate(
    CI_Likes = paste0("[", round(Lower_Likes, 3), ", ", round(Upper_Likes, 3), "]"),
    CI_Comentarios = paste0("[", round(Lower_Comentarios, 3), ", ", round(Upper_Comentarios, 3), "]"),
    significativo_likes = (Lower_Likes > 0 & Upper_Likes > 0) | (Lower_Likes < 0 & Upper_Likes < 0),
    significativo_comentarios = (Lower_Comentarios > 0 & Upper_Comentarios > 0) | (Lower_Comentarios < 0 & Upper_Comentarios < 0)
  ) %>%
  mutate(
    Est_Likes = round(Est_Likes, 3),
    Est_Comentarios = round(Est_Comentarios, 3)
  )

# Reorganizar columnas
df_tabla <- df_combinado %>%
  select(term, Est_Likes, CI_Likes, Est_Comentarios, CI_Comentarios,
         significativo_likes, significativo_comentarios)

colnames(df_tabla)[1] <- "Predictor"

# Cabecera jerárquica
cabecera <- data.frame(
  col_keys = colnames(df_tabla)[1:5],
  nivel1 = c("Predictors", "Likes (Trf Log)", "Likes (Trf Log)",
             "Comentarios (Trf Log)", "Comentarios (Trf Log)"),
  nivel2 = c("Predictors", "Estimates", "IC", "Estimates", "IC"),
  stringsAsFactors = FALSE
)

# Crear flextable con negrita condicional
ft_modelos <- flextable(df_tabla[, 1:5]) %>%
  set_header_df(mapping = cabecera, key = "col_keys") %>%
  merge_h(part = "header") %>%
  bold(i = ~ df_tabla$significativo_likes == TRUE, j = c("Est_Likes", "CI_Likes"), part = "body") %>%
  bold(i = ~ df_tabla$significativo_comentarios == TRUE, j = c("Est_Comentarios", "CI_Comentarios"), part = "body") %>%
  autofit()

### 9. Mostrar tabla
ft_modelos


```

```{r}
# Renombrar columna 'term' a 'Predictor'
df_tabla_latex <- df_combinado %>%
  select(term, Est_Likes, CI_Likes, Est_Comentarios, CI_Comentarios,
         significativo_likes, significativo_comentarios) %>%
  rename(Predictor = term)

# Aplicar negritas si son significativos
df_tabla_latex <- df_tabla_latex %>%
  mutate(
    Est_Likes = ifelse(significativo_likes, paste0("\\textbf{", Est_Likes, "}"), as.character(Est_Likes)),
    CI_Likes = ifelse(significativo_likes, paste0("\\textbf{", CI_Likes, "}"), as.character(CI_Likes)),
    Est_Comentarios = ifelse(significativo_comentarios, paste0("\\textbf{", Est_Comentarios, "}"), as.character(Est_Comentarios)),
    CI_Comentarios = ifelse(significativo_comentarios, paste0("\\textbf{", CI_Comentarios, "}"), as.character(CI_Comentarios))
  ) %>%
  select(-significativo_likes, -significativo_comentarios)

# Diccionario de nombres legibles
nombres_bonitos <- c(
  "edad.log" = "Edad (Trf Log)",
  "es_usaSí" = "Estadounidense", 
  "publicaciones.log" = "Publicaciones (Trf Log)",
  "seguidores.log" = "Seguidores (Trf Log)",
  "posicion_owgr.log" = "Ranking mundial (Trf Log)",
  "inicio_profesional" = "Inicio profesional",
  "dinero_2024.log" = "Dinero 2024 (Trf Log)",
  "circuitoPGA" = "Circuito PGA",
  "n_otros_circuitos" = "Otros circuitos",
  "n_torneos_total" = "Torneos jugados",
  "n_torneos_pga" = "Torneos PGA",
  "n_torneos_liv" = "Torneos LIV",
  "n_torneos_otros_circuitos" = "Torneos otros circuitos",
  "n_majors" = "Torneos Majors",
  "juegos_olimpicosSí" = "Juegos Olímpicos",
  "MastersSí" = "Masters de Augusta",
  "PGA_ChampionshipSí" = "PGA Championship",
  "US_OpenSí" = "US Open",
  "The_OpenSí" = "The Open",
  "carruselSí" = "Carrusel",
  "n_fotos" = "Nº Fotos",
  "n_videos" = "Nº Videos",
  "n_palabras.log" = "Nº Palabras (Trf Log)",
  "n_hashtags" = "Nº Hashtags",
  "n_menciones" = "Nº Menciones",
  "n_emojis" = "Nº Emojis",
  "campo_golfSí" = "Campo de golf",
  "indoorSí" = "Indoor",
  "n_rostros" = "Nº Rostros",
  "selfieSí" = "Selfie",
  "otro_golfistaSí" = "Otro golfista",
  "brysondechambeau_topSí" = "Bryson Dechambeau",
  "tyrrellhatton_topSí" = "Tyrrell Hatton",
  "jonrahm_topSí" = "Jon Rahm",
  "joaco_niemann_topSí" = "Joaco Niemann",
  "cameronsmithgolf_topSí" = "Cameron Smith",
  "scottie.scheffler_topSí" = "Scottie Scheffler",
  "xanderschauffele_topSí" = "Xander Schauffele",
  "rorymcilroy_topSí" = "Rory McIlroy",
  "collin_morikawa_topSí" = "Collin Morikawa",
  "luddeaberg_topSí" = "Ludvig Åberg",
  "emocionhappy" = "Felicidad",
  "emocionsurprise" = "Sorpresa",
  "emocionfear" = "Miedo",
  "emociondisgust" = "Asco",
  "emocionangry" = "Enfado",
  "emocionsad" = "Tristeza",
  "dia_semanaMar" = "Martes",
  "dia_semanaMié" = "Miércoles",
  "dia_semanaJue" = "Jueves",
  "dia_semanaVie" = "Viernes",
  "dia_semanaSáb" = "Sábado",
  "dia_semanaDom" = "Domingo"
)

# Renombrar predictores
df_tabla_latex$Predictor <- dplyr::recode(df_tabla_latex$Predictor, !!!nombres_bonitos)

# Definir bloques
bloques <- list(
  "(Intercept)",
  "Usuario" = c("Edad (Trf Log)", "Estadounidense", "Publicaciones (Trf Log)", "Seguidores (Trf Log)"),
  "Información deportiva" = c("Ranking mundial (Trf Log)", "Inicio profesional", "Dinero 2024 (Trf Log)", "Circuito PGA", "Otros circuitos", "Torneos jugados", "Torneos PGA", "Torneos LIV", "Torneos otros circuitos", "Torneos Majors"),
  "Publicaciones en Majors y JJOO" = c("Juegos Olímpicos", "Masters de Augusta", "PGA Championship", "US Open", "The Open"),
  "Publicación" = c("Carrusel", "Nº Fotos", "Nº Videos"),
  "Día de la semana (ref=Lunes)" = c("Martes", "Miércoles", "Jueves", "Viernes", "Sábado", "Domingo"),
  "Texto" = c("Nº Palabras (Trf Log)", "Nº Hashtags", "Nº Menciones", "Nº Emojis"),
  "Imagen" = c("Campo de golf", "Indoor", "Nº Rostros", "Selfie", "Otro golfista"),
  "Emoción (ref=Neutral)" = c("Felicidad", "Sorpresa", "Miedo", "Asco", "Enfado", "Tristeza"),
  "Jugadores destacados" = c("Bryson Dechambeau", "Tyrrell Hatton", "Jon Rahm", "Joaco Niemann", "Cameron Smith", "Scottie Scheffler", "Xander Schauffele", "Rory McIlroy", "Collin Morikawa", "Ludvig Åberg")
)

# Asignar grupo
df_tabla_latex$grupo <- sapply(df_tabla_latex$Predictor, function(x) {
  match <- names(bloques)[sapply(bloques, function(b) x %in% b)]
  if (length(match) == 0) "Otros" else match
})

# Ordenar por grupo
df_tabla_latex <- df_tabla_latex %>%
  arrange(factor(grupo, levels = names(bloques)), match(Predictor, unlist(bloques)))

# Crear tabla base
tabla_final <- kable(df_tabla_latex[, 1:5],
                     format = "latex",
                     booktabs = TRUE,
                     escape = FALSE,
                     caption = "Estimaciones e IC95 para Likes y Comentarios") %>%
  add_header_above(c(" " = 1, "Likes (log)" = 2, "Comentarios (log)" = 2)) %>%
  kable_styling(latex_options = c("scale_down", "striped", "HOLD_position"), position = "center")

# Insertar separadores por grupo (en cursiva sin negrita)
for (bloque in rev(names(bloques))) {
  pred_en_bloque <- bloques[[bloque]]
  n_filas <- sum(df_tabla_latex$Predictor %in% pred_en_bloque)
  if (n_filas > 0) {
    idx <- which(df_tabla_latex$Predictor %in% pred_en_bloque)[1]
    tabla_final <- group_rows(
      tabla_final,
      group_label = paste0("\\textit{", bloque, "}"),
      start_row = idx,
      end_row = idx + n_filas - 1,
      escape = FALSE
    )
  }
}

# Ajuste final del código LaTeX: encabezado personalizado y quitar negrita en bloques
latex_code <- as.character(tabla_final)

# Cambiar el encabezado de la tabla
latex_code <- gsub(
  pattern = "\\\\begin\\{tabular\\}\\[t\\]\\{.*?\\}",
  replacement = "\\\\resizebox{0.75\\\\linewidth}{!}{\n\\\\begin{tabular}[t]{lcccc}",
  x = latex_code
)

# Cerrar correctamente el resizebox al final
latex_code <- gsub(
  pattern = "\\\\end\\{tabular\\}",
  replacement = "\\\\end{tabular}}",
  x = latex_code
)

# Eliminar negrita de encabezados de grupo
latex_code <- gsub(
  pattern = "\\\\textbf\\{\\\\textit\\{(.*?)\\}\\}",
  replacement = "\\\\textit{\\1}",
  x = latex_code
)

# Mostrar LaTeX final
cat(latex_code)
```

